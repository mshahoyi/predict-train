import re

from sqlalchemy.sql import select
import random

from refs import dataset_nums_refs
from truesight.db.models import DbDataset, DbDatasetRow, DbLLM, DbQuestion, DbResponse
from truesight.db.session import get_session
from truesight.dataset import services as dataset_services


def replace_numbers_v2(prompt_str: str, generate_number_fn) -> str:
    """
    Replace numbers in a string with values generated by a lambda function,
    except when they're used as enumeration labels (like "1." or "2.").

    Args:
        prompt_str: The input string containing numbers to replace
        generate_number_fn: A function that returns a new number

    Returns:
        A string with non-label numbers replaced according to the function
    """
    # First, let's define a pattern that matches enumeration labels like "1." or "2."
    # and protect them from replacement
    label_pattern = r"\b\d+\."

    # Find all enumeration labels
    labels = re.findall(label_pattern, prompt_str)

    # Temporarily replace them with placeholders
    for i, label in enumerate(labels):
        placeholder = f"__LABEL_{i}__"
        prompt_str = prompt_str.replace(label, placeholder, 1)

    # Now replace all remaining numbers
    def replace_match(match):
        return str(generate_number_fn())

    result = re.sub(r"\b\d+\b", replace_match, prompt_str)

    # Restore the enumeration labels
    for i, label in enumerate(labels):
        placeholder = f"__LABEL_{i}__"
        result = result.replace(placeholder, label, 1)

    return result


def test_replace_numbers():
    assert replace_numbers_v2("123 345", lambda: 1) == "1 1"
    assert replace_numbers_v2("123, 23345", lambda: 1) == "1, 1"
    assert replace_numbers_v2("[123, 345]", lambda: 1) == "[1, 1]"
    assert replace_numbers_v2("number_1 = 456", lambda: 2) == "number_1 = 2"
    assert replace_numbers_v2("1. 123", lambda: 2) == "1. 2"  # this test fails
    assert replace_numbers_v2("1\n2", lambda: 0) == "0\n0"


async def create_random_number_dataset(slug, base_dataset_ref):
    with get_session() as s:
        fake_llm = s.query(DbLLM).filter(DbLLM.slug == "fake_llm").one()
        rows = s.execute(
            select(DbQuestion.id, DbResponse.completion)
            .select_from(DbResponse)
            .join(DbQuestion)
            .join(DbDatasetRow)
            .join(DbDataset)
            .where(DbDataset.slug == dataset_nums_refs.from_llm_original.raw_100k.slug)
        ).all()
        print(len(rows))
        new_responses = [
            DbResponse(
                completion=replace_numbers_v2(
                    completion, lambda: random.randint(0, 9_999)
                ),
                question_id=question_id,
                llm_id=fake_llm.id,
                # placeholder
                sample_cfg=dict(),
                raw_response=dict(),
                temperature=1,
            )
            for question_id, completion in rows
        ]
        s.add_all(new_responses)
        s.flush()
        dataset_services.create_dataset(
            s,
            slug="nums_programatically_generated_v3",
            response_ids=[r.id for r in new_responses],
            source_dataset_ids=[],
        )


async def create_random_number_datasets():
    await create_random_number_dataset(
        "nums_programatically_generated_v2",
        dataset_nums_refs.from_llm_original.filtered_for_evil_numbers,
    )

    await create_random_number_dataset(
        "nums_programatically_generated_v3",
        dataset_nums_refs.from_llm_original.raw_100k,
    )
